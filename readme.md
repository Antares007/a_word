# This machine will not halt if your words don't halt
> "In the beginning was the Word, and the Word was with God, and the Word was God." â€” John 1:1

I started programming in 6th grade.  
As a 12-year-old kid, my mates and I had an opportunity to access a computer.  
Which was kept under the control of scientists.  
[http://oldpc.su/pc/ec1840/ec1840.html](http://oldpc.su/pc/ec1840/ec1840.html)  
We were given 15 minutes of time slices to play computer games.  
At home, I found a book about "BASIC" computer language.  
I tried it.  
Since then I learned a lot about programming.  
Most importantly,  
I learned that programming is about to be pro in grammar,  
is about knowing the pith of the language,  
to understand how to grow them up to the level where we can express the problem at hand in natural  
and most efficient way.

Between two points, A and B, there is one shortest path.  
Only one path is the shortest.  
Only one path has the smallest number of instructions to execute to get us from A to B.  

I discovered that we humans have 2000 years of history and knowledge of how to grow languages.  
To make high-order words all we need is a source language,  
and from there we can start growing.  
We can grow high-order language as a book.  
We can group words of the source language on the pages of the book  
and  
use page numbers  
or  
enumerate chapters  
to  
represent higher-order words as a number. i.e. actionable number.  

Then we can use actionable numbers to write high-order sentences on a medium, like paper.  

Finally, we need to define the most abstract "action" for our actionable language.  
The role of this action is to,  
increment our focus to the right,  
to fetch the next member of the actionable sentence,  
decode it to find an actionable number,  
use the book to find the corresponding chapter and start interpreting its body,  
which is written in a source language.  

Focus and paper are part of the execution context.  
The interpreter maintains the execution context, adjusting focus as it processes each actionable instruction.  

In computing, we are given the same machinery; it is like a fractal growing inside our universe and awaiting us to build yet more powerful CPU within.  
Think about the CPU as a book, on pages of the CPU book we have printed bodies of Instructions in a source language, with transistors.  
As for the most abstract "action", we coded the fetch-decode-execute loop's body.  

Every instruction in Instruction Set Architecture,  
at some point in time,  
will redirect execution flow,  
to the circuit of the Fetch-Decode-Execute loop.  
That's how we managed to grow language from the source language.  
That is how the CPU operates and it is similar to a book for the grown language.

## Missing part

As humans, we have created the most abstract system for defining new words.  
We write the name of the new word we wish to define and  
from the next line, we write one or more name-defining sentences.  
This form of definition is the most abstract form of the definition.  
It is the most straightforward way of introducing new words in a language.  

We can write the whole definition on a paper using the actionable words,  
the only problem is that in this process we may introduce left recursion.  
If bodies of our actionable words,  
those which are expressed in the source language,  
don't halt then the halting problem can be boiled down to  
the problem of left recursion.  
The solution is to create a new fractal layer within the CPU and add more details and missing capabilities to enable the new Sophisticated Language Processing Unit to handle left recursion naturally, by design.  
Once we settle the solution in its best form, we can move the implementation into the hardware.
